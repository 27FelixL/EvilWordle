"""
Student information for this assignment:

On my honor, Felix Li, this
programming assignment is my own work and I have not provided this code to
any other student.

I have read and understand the course syllabus's guidelines regarding Academic
Integrity. I understand that if I violate the Academic Integrity policy (e.g.
copy code from someone else, have the code generated by an LLM, or give my
code to someone else), the case shall be submitted to the Office of the Dean of
Students. Academic penalties up to and including an F in the course are likely.

UT EID 1: fl7449
"""

import random
import sys

# ANSI escape codes for text color
# These must be used by wrapping it around a single character string
# for the test cases to work. Please use the color_word function to format
# the feedback properly.

CORRECT_COLOR = "\033[3;1;102m"
WRONG_SPOT_COLOR = "\033[3;1;90;103m"
NOT_IN_WORD_COLOR = "\033[3;1m"
NO_COLOR = "\033[0m"

# Used for the explanation.
BOLD_COLOR = "\033[1m"

# If you are colorblind for yellow and green, please use these colors instead.
# Uncomment the two lines below. Commenting in and out can be done by
# highlighting the  lines you care about and using:
# on a windows/linux laptop: ctrl + /
# on a mac laptop: cmd + /

# CORRECT_COLOR = "\033[3;1;97;101m"
# WRONG_SPOT_COLOR = "\033[3;1;97;104m"

# The total number of letters allowed
NUM_LETTERS = 5

INVALID_INPUT = "Bad input detected. Please try again."


class Keyboard:
    """
    The Keyboard class displays and updates a text-based keyboard that prints
    after every guess.
    """

    def __init__(self):
        """
        Initializes the Keyboard object by setting up the rows of keys and initializing
        each key with a default state.
        """
        self.rows = ("qwertyuiop", "asdfghjkl", "zxcvbnm")
        self.colors = {letter: NO_COLOR for letter in "qwertyuiopasdfghjklzxcvbnm"}

    def update(self, feedback_colors, guessed_word):
        """
        Updates the color of each letter on the keyboard based on feedback from a guessed word.
        """
        for i, letter in enumerate(guessed_word):
            color = feedback_colors[i]
            if color == CORRECT_COLOR:
                self.colors[letter] = CORRECT_COLOR
            elif color == WRONG_SPOT_COLOR and self.colors[letter] != CORRECT_COLOR:
                self.colors[letter] = WRONG_SPOT_COLOR
            elif color == NOT_IN_WORD_COLOR and self.colors[letter] == NO_COLOR:
                self.colors[letter] = NOT_IN_WORD_COLOR

    def __str__(self):
        """
        Returns a string representation of the keyboard, showing each letter in its
        corresponding color.
        """
        formatted_rows = []
        leading_spaces = [0, 1, 3]
        for i, row in enumerate(self.rows):
            formatted_row = " ".join([color_word(self.colors[letter], letter) for letter in row])
            formatted_rows.append(" " * leading_spaces[i] + formatted_row)
        return "\n".join(formatted_rows)

class WordFamily:
    """
    A class representing a group or 'family' of words that match a specific
    pattern of feedback_colors.
    """
    COLOR_DIFFICULTY = {CORRECT_COLOR: 0, WRONG_SPOT_COLOR: 1, NOT_IN_WORD_COLOR: 2}

    def __init__(self, feedback_colors, words):
        """
        Initializes the WordFamily based on the feedback colors list. 
        """
        self.feedback_colors = feedback_colors
        self.words = words
        self.difficulty = sum(WordFamily.COLOR_DIFFICULTY[color] for color in feedback_colors)

    def __lt__(self, other):
        """
        Compares this WordFamily object with another to make it as difficult as possible. 
        """
        if not isinstance(other, WordFamily):
            raise NotImplementedError("< operator only valid for WordFamily comparisons.")
        return (-len(self.words), -self.difficulty, self.feedback_colors) < \
        (-len(other.words), -other.difficulty, other.feedback_colors)

    def __str__(self):
        return (
            f"({len(self.words)}, {self.difficulty}, "
            f"{color_word(self.feedback_colors, ['â–‘'] * 5)})"
        )

    def __repr__(self):
        return str(self)

def print_explanation(attempts):
    """Prints the 'how to play' instructions on the official website"""

    print("Welcome to Command Line Evil Wordle!")
    print()

    print("".join([BOLD_COLOR + letter + NO_COLOR for letter in "How To Play"]))
    print(f"Guess the secret word in {attempts} tries.")
    print("Each guess must be a valid 5-letter word.")
    print("The color of the letters will change to show")
    print("how close your guess was.")
    print()

    print("Examples:")
    print(CORRECT_COLOR + "w" + NO_COLOR, end="")
    print("".join([NOT_IN_WORD_COLOR + letter + NO_COLOR for letter in "eary"]))
    print(BOLD_COLOR + "w" + NO_COLOR, end=" ")
    print("is in the word and in the correct spot.")

    print(NOT_IN_WORD_COLOR + "p" + NO_COLOR, end="")
    print(WRONG_SPOT_COLOR + "i" + NO_COLOR, end="")
    print("".join([NOT_IN_WORD_COLOR + letter + NO_COLOR for letter in "lls"]))
    print(BOLD_COLOR + "i" + NO_COLOR, end=" ")
    print("is in the word but in the wrong spot.")

    print("".join([NOT_IN_WORD_COLOR + letter + NO_COLOR for letter in "vague"]))
    print(BOLD_COLOR + "u" + NO_COLOR, end=" ")
    print("is not in the word in any spot.")
    print()

def color_word(colors, word):
    """
    Colors a given word using ANSI formatting then returns it as a new string.
    """
    if isinstance(colors, str):
        colors = [colors]

    assert len(colors) == len(word), "The length of colors and word do not match."

    colored_word = [None] * len(word)
    for i, character in enumerate(word):
        colored_word[i] = f"{colors[i]}{character}{NO_COLOR}"

    return "".join(colored_word)

def get_attempt_label(attempt_number):
    """
    Generates the label for the given attempt number.
    """
    if 11 <= attempt_number <= 12:
        suffix = "th"
    else:
        suffix = {1: "st", 2: "nd", 3: "rd"}.get(attempt_number % 10, "th")

    return f"{attempt_number}{suffix}"

def prepare_game():
    """
    Prepares the game by setting the number of attempts and loading the initial
    pool of valid words.
    """
    valid_words_file_name = "valid_guesses.txt"
    if len(sys.argv) > 3:
        raise ValueError()
    if sys.argv[-1] == "debug":
        valid_words_file_name = "test_guesses.txt"
        sys.argv.pop()
    if len(sys.argv) == 1:
        attempts = 6
    elif sys.argv[1].isnumeric():
        attempts = int(sys.argv[1])
        if not 1 < attempts < 100:
            raise ValueError()
    else:
        raise ValueError()
    with open(valid_words_file_name, "r", encoding="ascii") as valid_words:
        valid_words = [word.rstrip() for word in valid_words.readlines()]
    return attempts, valid_words

def fast_sort(lst):
    """
    Returns a new list with the same elements as lst sorted in ascending order. 
    """
    if len(lst) <= 1:
        return lst
    mid = len(lst) // 2
    left = fast_sort(lst[:mid])
    right = fast_sort(lst[mid:])
    sorted_list = []
    i = j = 0
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            sorted_list.append(left[i])
            i += 1
        else:
            sorted_list.append(right[j])
            j += 1
    sorted_list.extend(left[i:])
    sorted_list.extend(right[j:])
    return sorted_list

def get_feedback_colors(secret_word, guessed_word):
    """
    Processes the guess and generates the colored feedback based on the potential secret word. 
    """
    feedback = [NOT_IN_WORD_COLOR] * NUM_LETTERS
    secret_word_counts = {letter: secret_word.count(letter) for letter in set(secret_word)}
    for i, letter in enumerate(guessed_word):
        if secret_word[i] == letter:
            feedback[i] = CORRECT_COLOR
            secret_word_counts[letter] -= 1
    for i, letter in enumerate(guessed_word):
        if feedback[i] == NOT_IN_WORD_COLOR and letter in secret_word_counts \
            and secret_word_counts[letter] > 0:
            feedback[i] = WRONG_SPOT_COLOR
            secret_word_counts[letter] -= 1
    return feedback

def get_feedback(remaining_secret_words, guessed_word):
    """
    Processes the guess and generates the colored feedback based on the hardest word family.
    """
    word_families = {}
    for word in remaining_secret_words:
        feedback_colors = tuple(get_feedback_colors(word, guessed_word))
        if feedback_colors not in word_families:
            word_families[feedback_colors] = []
        word_families[feedback_colors].append(word)
    word_family_list = [WordFamily(pattern, words) for pattern, words in word_families.items()]
    hardest_family = fast_sort(word_family_list)[0]
    return hardest_family.feedback_colors, hardest_family.words

def main():
    """
    This function is the main loop for the game. It calls prepare_game() to set up the game,
    then it loops continuously until the game is over.
    """
    try:
        valid = prepare_game()
    except ValueError:
        print(INVALID_INPUT)
        return
    attempts, valid_guesses = valid
    secret_words = valid_guesses
    print_explanation(attempts)
    keyboard = Keyboard()
    attempt = 1
    while attempt <= attempts:
        attempt_number_string = get_attempt_label(attempt)
        prompt = f"Enter your {attempt_number_string} guess: "
        guess = input(prompt)
        if not sys.stdin.isatty():
            print(guess)
        if guess not in valid_guesses:
            print(INVALID_INPUT)
            continue
        feedback_colors, secret_words = get_feedback(secret_words, guess)
        feedback = color_word(feedback_colors, guess)
        print(" " * (len(prompt) - 1), feedback)
        keyboard.update(feedback_colors, guess)
        print(keyboard)
        print()
        if len(secret_words) == 1 and guess == secret_words[0]:
            print("Congratulations! ", end="")
            print("You guessed the word '" + feedback + "' correctly.")
            break
        attempt += 1
    if attempt > attempts:
        random.seed(0)
        secret_words = fast_sort(secret_words)
        random.seed(0)
        secret_word = random.choice(secret_words)
        formatted_secret_word = "".join(
            [CORRECT_COLOR + c + NO_COLOR for c in secret_word]
        )
        print("Sorry, you've run out of attempts. The correct word was ", end="")

        print("'" + formatted_secret_word + "'.")

if __name__ == "__main__":
    main()
